Tier 1 â€” High-Value, Low-Complexity (Do These Now)

These fixes give you stability and performance without major rewrites.

Area	Why it Matters	Complexity	Recommendation
Replace requests with httpx.AsyncClient	Unblocks event loop, 3â€“5Ã— faster under load	ğŸ”¹Low	âœ… Do it now
Dependency Injection / Lazy Init	Stops global crashes, simplifies tests	ğŸ”¹Low-Medium	âœ… Worth it
Add retry/backoff + simple rate limiting	Prevents external API meltdowns	ğŸ”¹Low	âœ… Easy win
Cache expensive report prompts (in-memory)	Cuts redundant calls, saves cost	ğŸ”¹Low	âœ… Quick to add
Remove dead code	Shrinks cognitive load instantly	ğŸ”¹Low	âœ… Immediate cleanup
Frontend debouncing + simple state machine	Prevents duplicate unlocks, improves UX	ğŸ”¹Low	âœ… Should do

ğŸ‘‰ ROI: These can all be done in 2â€“3 dev days and eliminate 80% of your current brittleness.

ğŸŸ¡ Tier 2 â€” Medium-Value, Medium-Complexity (Next Sprint)

These improve maintainability and testability but add some overhead. Worth doing after Tier 1 is complete.

Area	Why it Matters	Complexity	Recommendation
Better service boundaries (Crawler â†’ Licensing â†’ AI)	Enables isolated testing, swap-ability	ğŸ”¹Medium	âœ… Do incrementally
Centralized state manager on frontend	Scales UI logic cleanly	ğŸ”¹Medium	âœ… Worth it soon
Structured error handling + unified API responses	Improves debugging and reliability	ğŸ”¹Medium	âœ… Add gradually

ğŸ‘‰ Do these once youâ€™re past initial customer demos â€” theyâ€™ll make the system far easier to extend.

ğŸ”µ Tier 3 â€” Long-Term, High-Complexity (Defer)

These are valuable but not urgent. Implement only once traffic or feature count justifies the extra moving parts.

Area	Why it Matters	Complexity	Recommendation
Circuit breakers & observability (aiobreaker, OpenTelemetry)	Production resilience at scale	ğŸ”¹High	ğŸš§ Defer
Event-driven architecture / background job queue	Enables async enrichment and decoupling	ğŸ”¹High	ğŸš§ Defer
Hexagonal architecture / containerization	Clean long-term modularity	ğŸ”¹High	ğŸš§ Future phase

ğŸ‘‰ Great for v2 when you start parallelizing enrichments or integrating multiple data sources.

ğŸ¯ Recommended Path

If your goal is â€œmore stable and performant without adding unnecessary complexity,â€
then your order of operations should be:

Async + dependency injection cleanup

Add caching and retry/backoff

Remove dead code and fix error consistency

Refactor the worst coupling (Crawler â†’ Licensing)

After that, stop. Donâ€™t over-architect yet.
Your current design will comfortably scale 10Ã— in usage with just those changes.