I‚Äôll help you troubleshoot this progressively. Let's first look at likely culprits affecting rendering or agent failure.

üß† Issue #1: polish_sources is NOT async (blocking call inside async context)

In _polish_sources_claude() you‚Äôre calling:

polished_sources = self.ai_service.polish_sources(query, raw_sources)


If polish_sources() is a blocking (sync) method, it will block the entire event loop, potentially delaying or hanging your enrichment task. That might explain why polished data isn't updating and cards feel ‚Äústuck.‚Äù

‚úÖ Fix:
Wrap it in a thread executor to prevent blocking:

import asyncio

# Replace sync call with this:
loop = asyncio.get_event_loop()
polished_sources = await loop.run_in_executor(None, self.ai_service.polish_sources, query, raw_sources)


You should also ensure polish_sources() itself isn‚Äôt too slow (e.g. batch Claude calls vs one at a time).

üß† Issue #2: Caching may prevent progressive updates if cache_key is reused too early

You cache the skeleton result immediately, and then also store the enriched result with the same key. This is good ‚Äî but:

The frontend might pull from the first cache hit without checking for freshness.

Or worse, if generate_sources_progressive() is called again before enrichment finishes, it might short-circuit to the old cache (which is still in skeleton stage).

‚úÖ Fix:
Return an extra field:

"stage": "skeleton", 
"enrichment_needed": True,
"refresh_hint": timestamp_or_version


Then use timestamp or cache_version to force frontend refresh.

üß† Issue #3: You're not updating cards with polished content if the index mismatches

In _polish_sources_claude(), you update like this:

for i, (source, polished) in enumerate(zip(sources, polished_sources)):
    if polished:
        source.title = polished.get('title', source.title)
        source.excerpt = polished.get('excerpt', source.excerpt)


But if polished_sources is shorter or re-ordered for any reason, zip() silently fails.

‚úÖ Fix:
Match by url or id, not index:

for polished in polished_sources:
    matching = next((s for s in sources if s.url == polished.get('url')), None)
    if matching:
        matching.title = polished.get('title', matching.title)
        matching.excerpt = polished.get('excerpt', matching.excerpt)

üß† Issue #4: You‚Äôre calling create_task() from within async def context (safe), but‚Ä¶

asyncio.create_task() does not guarantee execution order or completion before the request returns. This is fine, but if your system doesn't poll cache_key later or lacks a listener that triggers refresh, you‚Äôre flying blind.

‚úÖ Fix:
Make sure your frontend is:

polling cache_key

or using a websocket / SSE hook to watch for cache update

or retries generate_sources_progressive() after enrichment_needed = True

‚úÖ Discovery Phase ‚â† Licensing Risk

You're already enforcing:

source.unlock_price = 0.0  # Free by default, real licensing sets price


And you only apply price via _apply_licensing_info(), which is fine.

Just make sure Claude polishing never includes full text (just title/snippet) and you‚Äôre fine legally and financially for the free discovery tier.