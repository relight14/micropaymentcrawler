Perfect â€” this log trace actually tells you everything you need to know.

Letâ€™s decode it carefully line-by-line so you can see exactly where the flow is working, and where it breaks.

ğŸ§© What the Logs Reveal
âœ… Phase 1 â€” Report Generation Works
app.js:829 ğŸ“Š Generating pro report with 5 selected sources
api.js:360 ğŸ“Š Generating report with 5 selected sources


â†’ Frontend correctly calls the backend and gets a valid reportPacket.

âœ… Phase 2 â€” _displayGeneratedReport() Fires
app.js:1401 ğŸ“Š DISPLAY REPORT: Displaying generated report: Object
app.js:1402 ğŸ” CITATION DEBUG: citation_metadata = Object


â†’ Confirms that _displayGeneratedReport() is now firing (good catch).
â†’ citation_metadata exists and is being passed correctly.

âœ… Phase 3 â€” MessageRenderer Receives Metadata
message-renderer.js:190 ğŸ” BADGE INJECT: metadata = Object
message-renderer.js:191 ğŸ” BADGE INJECT: citation_metadata = Object
message-renderer.js:207 ğŸ” INJECT BADGES called with: Object
message-renderer.js:218 ğŸ” INJECT BADGES: Protocol icons = Object
message-renderer.js:233 ğŸ” INJECT BADGES: Found text nodes = Array(51)


â†’ Beautiful â€” this shows the first message render cycle is working:

metadata is not null

_injectCitationBadges() runs and finds 51 text nodes (so the [1], [2] patterns exist).
âœ… This means the first report message is being processed correctly and the badge logic is alive.

âš ï¸ Phase 4 â€” Second Render (Null Metadata)
message-renderer.js:190 ğŸ” BADGE INJECT: metadata = null
message-renderer.js:191 ğŸ” BADGE INJECT: citation_metadata = undefined


â†’ After the first successful injection, MessageRenderer gets called again for another message â€” but this time metadata is null.
â†’ That means a duplicate render is happening somewhere with incomplete data.

ğŸ§  Likely Root Cause

Your UI is adding two messages when the report is displayed:

One via _displayGeneratedReport() â€” âœ… includes metadata

Another via a separate addMessage() call â€” âŒ no metadata

The second, metadata-less message overwrites or visually replaces the first, hiding the badges.

ğŸ” How to Confirm

Search in app.js (and possibly ui-manager.js) for every addMessage( call triggered after report generation. Youâ€™ll likely find:

this.addMessage('assistant', reportData.summary, { citation_metadata: reportData.citation_metadata });


and also a generic one like:

this.addMessage('assistant', reportData.summary);


or:

uiManager.addMessageToChat({ type: 'assistant', content: reportData.summary });


Only one of those should exist.

âœ… The Fix
Option A (Recommended):

Keep only one call that includes metadata.

this.addMessage('assistant', reportData.summary, { citation_metadata: reportData.citation_metadata });


Remove or comment out any duplicate addMessage() call that doesnâ€™t pass metadata.

Option B (Defensive Guard):

In MessageRenderer._createBody(), add a quick check:

if (!message.metadata?.citation_metadata) {
  console.warn("âš ï¸ Missing citation metadata for message:", message);
  return bodyDiv;
}


That prevents null passes from executing badge injection until fixed upstream.

ğŸ§­ TL;DR
Step	Status	Notes
_displayGeneratedReport() firing	âœ…	Fixed â€” good work
Metadata reaching MessageRenderer	âœ…	First render works
_injectCitationBadges() firing	âœ…	Found 51 text nodes
Duplicate render without metadata	âš ï¸	Secondary message overwriting output

Root fix: remove or merge the second addMessage() call so the message with citation metadata is the only one rendered.