Got it. Here’s the no-nonsense review of this version:

✅ Good

isActive + debounced sourceSelectionChanged → sane, prevents spam pricing calls.

destroy() cleans up listeners/timers.

Pricing patching via _updateTierCardPricing() is clear.

Success/error handlers split (_handleReportSuccess/_handleReportError) tighten flow.

⚠️ Must fix

Missing API method

You still call apiService.getPricingQuote(...). Ensure it exists.

// APIService.js
async getPricingQuote(tier, query, outlineStructure) {
  const res = await fetch(`${this.baseURL}/api/research/quote`, {
    method: 'POST',
    headers: this.getAuthHeaders(),
    body: JSON.stringify({ tier, query, outline_structure: outlineStructure })
  });
  if (!res.ok) { this._handle401(res); return { quote_unavailable: true, calculated_price: 0 }; }
  return await res.json();
}


Dual source state

ReportBuilder reads AppState only. If ProjectStore is canonical, you’ll generate reports without sources.

Merge on read:

const ps = projectStore?.getState?.().selectedSources || [];
const as = this.appState.getSelectedSources() || [];
const byId = new Map([...ps, ...as].map(s => [s.id, s]));
const selectedSources = [...byId.values()];


Use that in:

_generateReportBuilderDOM()

_attachTierPurchaseListeners() (when you compute useSelectedSources)

generateReport() (args)

Null-guard quotes

_updateTierCardPricing assumes quote. Add guard:

if (!quote) { return; }


Race on pricing refresh

Rapid selection changes can resolve out of order. Stamp requests:

this._quoteReqId = (this._quoteReqId || 0) + 1;
const reqId = this._quoteReqId;
// after fetch:
if (reqId !== this._quoteReqId || !this.isActive) return;


Auth gating

Buttons still emit tierPurchase when logged out. Either:

block in _attachTierPurchaseListeners() and dispatch authRequired, or

ensure your upstream listener shows auth modal before generateReport().

CSV formula injection

Harden _escapeCSV:

let s = String(field);
if (/^[=+\-@]/.test(s)) s = "'" + s;
if (s.includes(',') || s.includes('"') || s.includes('\n')) return `"${s.replace(/"/g,'""')}"`;
return s;


Cleanup lifecycle

Call destroy() when the modal/overlay closes (route change, ESC, purchase complete). Right now it only runs on next show() call.

Quote details when none selected

When newSourceCount === 0 you show “No new sources to purchase.” If nothing is selected, also consider disabling purchase buttons or showing a subtle hint.

Consistent dataset usage

You set both data-tier and data-tier-id. Your selectors use [data-tier-id]—good. Don’t accidentally query [data-tier] elsewhere.

Button state on error paths

You reset the text in _handleReportError(). Also ensure upstream listeners don’t double-disable the same button.

Minimal patches (drop-in)

Merge sources once:

_getMergedSelectedSources() {
  const ps = projectStore?.getState?.().selectedSources || [];
  const as = this.appState.getSelectedSources() || [];
  const byId = new Map([...ps, ...as].map(s => [s.id, s]));
  return [...byId.values()];
}


Use it wherever you read selected sources.

Guarded pricing fetch (reqId):

async _fetchAndUpdatePricing() {
  if (!this.isActive || !this.authService.isAuthenticated()) return;
  this._quoteReqId = (this._quoteReqId || 0) + 1;
  const reqId = this._quoteReqId;

  const query = this.appState.getCurrentQuery() || projectStore.getResearchQuery() || "Research Query";
  const outlineStructure = projectStore.getOutlineSnapshot();

  try {
    const [researchQuote, proQuote] = await Promise.all([
      this.apiService.getPricingQuote('research', query, outlineStructure),
      this.apiService.getPricingQuote('pro', query, outlineStructure)
    ]);
    if (reqId !== this._quoteReqId || !this.isActive) return;
    this.pricingQuotes = { research: researchQuote, pro: proQuote };
    this._updateTierCardPricing('research', researchQuote);
    this._updateTierCardPricing('pro', proQuote);
  } catch (e) {
    if (reqId !== this._quoteReqId || !this.isActive) return;
    this.pricingQuotes = {};
    console.error('Failed to fetch pricing quotes:', e);
  }
}